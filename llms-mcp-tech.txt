ClaudeのMCP（Model Context Protocol）の技術詳細

アーキテクチャ構成

MCPの基本アーキテクチャ（Host/Client/Serverモデル）の概念図。ホストアプリ（例：Cursor等）がMCPクライアント機能を持ち、標準化されたプロトコルを通じてMCPサーバーと通信し、各サーバーが外部サービス（GitHubやSlack、ローカルファイル等）に接続する。 ￼ ￼

MCPはクライアント-ホスト-サーバー型のアーキテクチャを採用しています ￼。ここで「ホスト」はClaude DesktopやIDE、チャットボットなどLLMを利用するアプリケーション本体を指し、その内部で複数の「クライアント」インスタンスを管理します ￼ ￼。各MCPクライアントは一つのMCPサーバーとの1対1の状態ful接続を担当し ￼、ホストとサーバー間のメッセージを双方向に中継します（リクエスト・レスポンス・通知の送受信） ￼ ￼。一方、MCPサーバーは軽量なプログラムで、特定のデータソースやツールへのアクセス機能を提供します ￼。複数のサーバーが存在し得ますが、それぞれが独立して特化機能（ファイル操作、DB問い合わせ、API連携など）を標準化インターフェースで公開します ￼。ホストは必要に応じて複数のクライアント/サーバーに接続し、各サーバーから得られるコンテキスト（データ）を集約してLLMに提供する役割を担います ￼。

この分散構成により、LLMアプリはUSB-Cハブのように単一の標準ポート（MCP）を通じて様々なデータ源にアクセスでき ￼ ￼、新しいデータソースごとに都度カスタム統合を作る必要がなくなります ￼。ホストが複雑なオーケストレーションやLLMとの対話管理を引き受け、サーバー側は狭い責務に集中して実装をシンプルに保てるよう設計されています ￼（例えば「ファイル閲覧サーバー」「Slack通知サーバー」など、それぞれが独立に追加・組み合わせ可能 ￼）。実際、AnthropicはGoogle DriveやSlack、GitHub、Postgres等向けのオープンソースMCPサーバー実装を公開しており ￼、開発者は自前のデータシステムをMCPサーバーとして公開したり、MCP対応AIクライアントに組み込んだりできます。

プロトコル仕様

MCPは通信プロトコルとしてJSON-RPC 2.0をベースに採用しています ￼ ￼。クライアントとサーバーはJSON形式のメッセージをやり取りし、リクエスト・レスポンス・通知という3種類のメッセージ型を持ちます ￼。各メッセージはJSON-RPC 2.0のフォーマット（jsonrpc: "2.0", id, method, params等のフィールド）に従って構造化されており、リクエストにはメソッド名とパラメータ、対応するレスポンスには結果もしくはエラーが含まれます ￼。通知メッセージは片方向でレスポンスを要求しない点を除き、同様にmethodと必要に応じたparamsを持ちます ￼。このように標準的なJSON-RPC形式を用いることで、言語や環境に依存しない統一的なメッセージ交換が実現されています。

通信形式とメッセージ構造の例: たとえばホストがサーバー上のツールを呼び出す場合、"method": "tools/call"といったメソッド名でリクエストを送り、パラメータにツール名や引数を含めます ￼。MCPサーバーは要求を処理して結果（成功ならデータや完了ステータス、失敗ならエラー情報）をJSONで返します。またサーバー側からホストへの通知として、進捗状況のアップデート（"method": "progress", パーセンテージ等）を送信したり ￼ ￼、ホスト側からサーバーへハートビート（"method": "ping", 生存確認）を送ることもできます ￼。通信のコネクション自体はステートフルなセッションとして管理され、初期化時にお互いの対応機能（サポートするリソース種別やツール種別、プロンプトテンプレート可否など）を宣言・照合する機能ネゴシエーションが行われます ￼ ￼。このネゴシエーションにより、クライアント・サーバー双方が利用可能な機能のみを使って以降のやり取りを進めることが保証されます ￼。

MCPプロトコルはトランスポート層に依存しない設計であり、具体的な通信路は用途に応じて選択できます ￼。一般的にはローカルでサーバープロセスを起動する場合は標準入出力（stdin/stdout）やローカルソケット経由でのやり取り（MCPクライアントライブラリがプロセスを生成しパイプ通信）を行い、リモートのサービスと通信する場合はHTTP＋Server-Sent Events（SSE）などを用いた長期接続で双方向通信を行います ￼。いずれの場合も上位レイヤーのメッセージはJSON-RPC準拠であり、トランスポートが違ってもプロトコル動作は統一されています（公式にはstdioやHTTP(S)+SSEが標準トランスポートとして提案されています ￼ ￼）。なお、MCPはオープン標準として策定されており、公式のSDKがPython/TypeScript/Javaなど複数言語で提供されています ￼ ￼。そのため、開発者は好きな言語でMCPサーバーやクライアントを実装でき、メッセージ構造さえ守れば相互運用が可能です。

セキュリティ設計

MCPは設計段階からセキュリティとアクセス制御を重視しています。アーキテクチャ上、ホスト・クライアント・サーバーの役割分離により明確なセキュリティ境界が設定できるようになっています ￼。LLM（Claude等）が企業の機密データやユーザーのローカルファイルにアクセスする際も、MCP経由であればそのやり取りを制御・監査できるポイントが生まれるため、安全性を担保しやすくなります ￼。以下の観点でMCPのセキュリティ設計を説明します。
	•	認証（Authentication）: MCPプロトコル自体はクライアントとサーバー間の認証方式を固定していませんが、リモート接続時にはOAuth 2.1など標準的な認証フローを利用できる拡張が用意されています ￼ ￼。実際、最新版のMCP仕様ではサーバーが未認証の要求を受け取った際にHTTP 401を返し、クライアントにOAuth認証を促す仕組みが記載されています ￼。また全ての通信をHTTPSなど適切に暗号化されたチャネル上で行うことが必須とされ ￼、アクセストークンはリクエストのヘッダに含め、URIパラメータ等で漏洩しないよう要求されています ￼。ローカル環境で動作するサーバーの場合、開発用途では認証なしでlocalhost上の接続を許可するケースもありますが、必要に応じてOSの認証機構やAPIキーによる認証を実装することも可能です。
	•	認可・アクセス制御（Authorization）: MCPホスト側でユーザーの許可を管理できるようになっています ￼。ホストアプリは、どのMCPサーバーに接続し何を行わせるかについてユーザーの同意を得た上でクライアントを起動し、サーバーとの間で送受されるリクエストを管理します ￼。例えばClaude Desktopでは設定ファイルに許可したサーバーの一覧を記述しオンにすることで、そのサーバーへのアクセスが有効化される仕組みです ￼ ￼。加えてサーバー実装側でも細かなアクセス制御が可能です。たとえばファイルシステムサーバーであれば特定ディレクトリ以下のみ閲覧を許可する、データベースサーバーであれば読み取り専用に制限する等、サーバーごとに許容する操作やデータ範囲を制限できます ￼ ￼。MCPの通信はすべてホスト経由で行われるため、モデル（LLM）が直接外部と裏で通信することはなく、ホストが不正な操作要求をフィルタリングしたりユーザーに確認を求めたりできます ￼。これにより、意図しないデータ流出や不正操作を防ぐ仕組みになっています。
	•	データ分離と最小権限（Data Isolation）: MCPではサーバーは原則として会話全文や他サーバーの情報を閲覧できません ￼。各サーバーはホストから与えられた必要最小限のプロンプトやパラメータ（例：検索クエリやファイル名など）にのみアクセスし、その要求に応じた処理を行います ￼。LLMとの対話履歴全体や他のサーバーから得た情報はホスト内に留められ、サーバー間で直接共有されることはありません ￼。仮に複数のサーバーの結果を組み合わせる必要がある場合も、ホストがハブとなって結果を取りまとめLLMに提示するため、サーバー同士はお互いの存在や処理内容を知らないまま動作します ￼。このコンテキストの分離により、例えば「社内データベース用サーバー」と「インターネット検索用サーバー」を同時に使う場合でも、双方のデータが混ざるリスクを抑えられます。さらにホスト側で操作ログを記録し、どのサーバーに対してどんなリクエスト（ツール実行やリソース取得要求）が行われたかを監査できるようにする実装も推奨されています ￼。以上により、MCPを介したLLMの外部データ利用は、直接APIを叩く場合に比べて認証・認可とデータ隔離の観点で安全性が高められた設計になっています。

通信フロー

MCPにおけるホスト（LLMアプリケーション）とサーバー間の通信フローは、明確な段階を経て進みます。以下では、具体例として「開発用IDE（Cursor）がバグ管理ツール（Linear）とチャットツール（Slack）のMCPサーバーを利用するケース」をもとに、接続から操作、終了までの流れを説明します ￼ ￼。
	1.	初期化フェーズ（接続と機能交渉）: ユーザーがホストアプリ内で特定のMCPサーバーを有効化したり統合機能を起動すると、ホストはまずそのMCPサーバーとの接続を確立します。 ￼通常ローカルサーバーであればプロセスを起動しstdin/stdoutで接続し、リモートなら所定のエンドポイントにHTTP(S)で接続してSSE受信を開始します。接続後、Capabilityネゴシエーション（機能交渉）が行われます。ホスト側からinitializeリクエストで自分の対応できる機能一覧（例: サポートするメソッドやプロトコルバージョン）を送り ￼、サーバーはレスポンスで提供可能なリソース種別・ツール一覧・プロトコルバージョン等を通知します ￼。ホストはそれらを突き合わせ、互いにサポートしている機能のみを使うように内部設定します。さらにホストは必要に応じて機能の列挙を行います。例えばサーバーが提供するツール一覧を取得する場合、ホストはtools/listメソッドでリクエストし ￼、サーバーから利用可能なツール（例：「チケット作成」「チケット割当」「コメント追加」等）の一覧が返されます ￼。すべての初期化手順が完了すると、ホストはサーバーにinitialized通知を送り通常動作の開始を宣言します ￼。
	2.	運用フェーズ（LLMからの要求とサーバー処理）: ユーザーがLLMに対して「外部データに関連した質問」や「ツールの実行指示」を与えると、ホスト内のLLM（Claude等）はプロンプト内容に基づいて適切なMCPサーバーのツールやリソースを使うよう推論します。例えばユーザーが「ログインページのバグチケットを作成して」と指示した場合、ホストはLLMの応答生成中にLinearサーバーのcreate_ticketツールを使う必要があると判断し、MCPクライアントを通じてtools/callリクエスト（メソッド: "tools/call", パラメータ: ツール名"create_ticket"と必要なフィールド）をLinearサーバーに送信します ￼。サーバー側ではチケット作成の処理（外部サービスのAPI呼び出し等）を実行し、生成されたチケットIDや内容を結果としてレスポンス返答します ￼。ホストは受け取った結果をユーザーやLLMに反映します。続いてユーザーが「この新しいチケットをSlackでチームに知らせて」と言うと、ホストは別のMCPサーバー（Slackサーバー）との接続が必要と判断します。まだ接続されていなければ同様の初期化を行い ￼、Slackサーバーに対しtools/callで「通知送信」ツールを呼び出します ￼。Slackサーバーは内部でSlackのAPIを呼び出してメッセージを投稿し、その結果を返します。ホストは「通知送信成功」をユーザーにフィードバックし、LLMの回答（「チケットを作成し、チームに通知しました」等）に反映させます。
	3.	外部データソースとの連携: 各MCPサーバーはバックエンドで固有の外部サービスやデータソースと通信します。上記の例では、Linear MCPサーバーはLinear（プロジェクト管理ツール）のAPIエンドポイントにHTTPリクエストを送りチケットを登録していますし、Slack MCPサーバーはSlackのWebhookやAPIを呼び出してメッセージ投稿を行っています【48†】。ファイルシステムMCPサーバーであればOSのファイルIOを呼び出し、データベースサーバーならDB接続してクエリを実行するでしょう。このようなサーバー内部の外部連携部分（固有API部分）はMCPプロトコルの範囲外ですが、各サーバー実装が責任を持って行います【48†】。サーバーは結果データのみを標準化フォーマットでホストに返すため、ホストやLLMは外部APIの詳細を意識する必要がありません。MCPを介することで、LLMが抽象化された手段で多様な外部ツール・データにアクセスできるわけです ￼。
	4.	維持・終了フェーズ: ホストとサーバーの接続が長時間に及ぶ場合、定期的に**ハートビート（Ping）**信号を送って接続維持確認を行います ￼。例えばホストが一定間隔でpingリクエストを送り、サーバーが応答することで両者とも相手が稼働中であることを確認します ￼。ユーザーがホストアプリ上でそのサーバー連携を無効化したり作業を終えた場合は、グレースフルな切断手順が取られます ￼。具体的にはホストがサーバーにshutdownリクエストを送りセッション終了の意図を伝え、サーバーが後片付けをしてレスポンスを返します ￼。その後ホストからexit通知を送って物理的な接続を閉じ ￼、サーバープロセスを終了またはアイドル状態にします。万一接続が不安定になった場合には、自動再接続やユーザーへのエラーメッセージ表示などのリカバリ処理もホスト側で管理します ￼。

以上がMCPにおける通信フローの全体像です。このように標準化された初期化〜実行〜終了の手順が定められているおかげで、どのような組み合わせのホストアプリとサーバーでも一貫したやり取りが可能になります ￼。ClaudeなどのLLMモデルはMCPを通して必要な外部コンテキストを動的に取得できるため、従来は事前知識に頼っていた回答も最新のデータに基づいて生成できるようになります。公式ドキュメントやSDKには上記フローのシーケンス図やサンプルコードも掲載されているので、さらなる詳細は ￼ ￼などを参照してください。例えばAnthropicの公式GitHubでは、前述のLinearやSlackのサーバー実装コード、Claude DesktopとMCPサーバーを繋ぐ設定例（claude_desktop_config.json）などが公開されています ￼ ￼。MCPのオープンなエコシステムにより、今後も対応ツールが増え汎用的なAI統合プラットフォームとして発展すると期待されています ￼ ￼。